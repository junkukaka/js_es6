<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>回调函数</title>
</head>
<body>
    <h3>JavaScript 回调函数（Callback Function）</h3>
    <p>在 JavaScript 中，回调函数（Callback Function） 是作为参数传递给另一个函数，并在适当的时候执行的函数。</p>
    <h3>为什么需要回调函数？</h3>
    <p>JavaScript 是单线程、异步的语言，在执行一些可能耗时的操作（如网络请求、定时器、文件读取等）时，
        需要使用回调函数来保证代码按照正确的逻辑执行，而不会阻塞主线程。</p>
    <h3>总结</h3>
    <ul>
        <li>回调函数是作为参数传递，并在合适的时候执行的函数。</li>
        <li>常用于异步操作（如定时器、网络请求）。</li>
        <li>数组方法（map, forEach, filter）也使用回调函数。</li>
        <li>回调地狱会导致代码难以维护，可以用 Promise 或 async/await 替代。</li>
    </ul>    
<script>
//1. 回调函数的基本用法
//回调函数就是一个普通函数，但它作为参数传递给另一个函数，并在适当的时候调用。
console.log("11111111111111111111111111111111111111111111111111111111111");
function greet(name, callback) {
    console.log("Hello, " + name);
    callback(); // 执行回调函数
}
function sayGoodbye() {
    console.log("Goodbye!");
}
// 传递 sayGoodbye 作为回调函数
greet("Alice", sayGoodbye);
//✅ sayGoodbye 作为 greet 函数的参数，在 greet 里被调用。

//2. 回调函数在异步操作中的应用
//JavaScript 处理异步任务（如定时器、网络请求、文件操作等）时，回调函数非常常见。
console.log("2222222222222222222222222222222222222222222222222222222222");
console.log("Start");
setTimeout(function() {
    console.log("This runs after 2 seconds.");
}, 2000);

console.log("End");
//setTimeout 不会阻塞代码，而是 2 秒后执行回调函数。

//3. 回调函数在数组方法中的应用
//JavaScript 中的许多数组方法（如 forEach、map、filter）都使用回调函数。
console.log("3333333333333333333333333333333333333333333333333333333333");         
let numbers = [1, 2, 3, 4];
numbers.forEach(function(number) {
    console.log(number);
});
// forEach 遍历数组，每个元素都执行一次回调函数。

///4. 回调函数用于处理异步请求
console.log("4444444444444444444444444444444444444444444444444444444444");
function fetchData(callback) {
    setTimeout(() => {
        console.log("Data fetched!");
        callback("Success");
    }, 1500);
}
function handleResponse(response) {
    console.log("Response:", response);
}
// 传递回调函数
fetchData(handleResponse);
//fetchData 完成后调用 handleResponse 处理返回数据。

console.log("5555555555555555555555555555555555555555555555555555555555");
//5. 回调地狱（Callback Hell）
setTimeout(() => {
    console.log("Step 1");
    setTimeout(() => {
        console.log("Step 2");
        setTimeout(() => {
            console.log("Step 3");
        }, 1000);
    }, 1000);
}, 1000);

//  问题：代码越来越深，难以维护。 使用 Promise ,使用 async/await    
//6. 解决方案：用 Promise 替代回调
console.log("6666666666666666666666666666666666666666666666666666666666");
function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log("Data fetched! this is promise");
            resolve("Success");
        }, 1500);
    });
}

fetchData().then(response => {
    console.log("Response:", response);
});

//Promise 让代码更清晰，避免了回调地狱。

//7. async/await 替代回调
console.log("7777777777777777777777777777777777777777777777777777777777");
async function getData() {
    let response = await fetchData();
    console.log(response);
}

getData();
//async/await 让异步代码更像同步代码，可读性更强！




</script>    
</body>
</html>